//이분탐색이 어디에 쓰일 것인가?
//이분탐색 하고 풀었는데 메모리초과가 난다면?
//다른 방법으로 이분탐색이 필요
//해당 문제의 경우는 구구단과 비슷.
//이분탐색 문제 같으면 long으로 선언하고
//무조건 bufferedReader 쓰기

k[11]을 구한다면? -> 이 값을 x로 두면
x보다 작거나 같은 값의 갯수가 b에 11개 있다는 뜻.

//key) -> right는 최대 11즉 m이된다.

//그렇다면 x를 구하려면 left = 1, right = m으로 설정 후
mid = l+r/2인데 이 mid를 어떻게 사용?

1 2 3 
2 4 6
3 6 9 그냥 구구단이다. 1행의 값은 123, 2행은 246
즉, i행 (i는 1부터) 
count += Math.min(mid/i , n)을 n개의 구구단 동안 하면 된다.

이유는 k가 3이라면 x보다 작거나 같은 수가 3개라는 뜻인데,
left가 1 m이 3이니까 mid = 2이다. 그러면
1단 -> 2/1 2/2 2/3 = 3 -> count = 3
2단 -> 2/2 2/4 2/6 = 1  -> count = 4
3단 -> 2/3 2/6 2/9 = 0 즉 mid가 2일때 count = 4이다.
m>count이므로 left를 mid로 올린다.

이때 count >= m으로 설정한 이유 (low_bound 인 이유는
우리는 m개와 같거나 큰 최소의 m을 찾아야한다.

upper-bound는 '초과하는 첫번째 인덱스 찾기'
lower-bound는 찾고자하는 값과 같거나 큰 첫번째 인덱스 찾기

